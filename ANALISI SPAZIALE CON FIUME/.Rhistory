plot(v.1, fit1, pch = 3)
# non stationary variogram v
v <- variogram(bc.med_dwell ~ sqrt(dist), data = data_spat)
plot(v)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,200,seq(400,6000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(0.4, "Exp", 3000, 0.2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,200,seq(400,6000,450)))
fit1=fit.variogram(v.1, vgm(0.4, model='Exp', 5000, nugget=0.2))
x11()
plot(v.1, fit1, pch = 3)
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,200,seq(400,3000,450)))
fit1=fit.variogram(v.1, vgm(0.4, model='Exp', 5000, nugget=0.2))
x11()
plot(v.1, fit1, pch = 3)
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,200,seq(400,3000,450)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(200,3000,450)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(200,3000,450)))
plot(v)
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(200,3000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v <- variogram(bc.med_dwell ~ sqrt(dist), data = data_spat)
plot(v)
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red', ylim=c(0.2,0.39))
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
# compare the two variograms
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red', ylim=c(0.2,0.39))
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red')
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
v <- variogram(bc.med_dwell ~ sqrt(dist), data = data_spat)
plot(v)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(200,3000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
# compare the two variograms
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red')
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red')
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
data(meuse)
## Define the sample coordinates
coordinates(meuse) <- c('x','y') #SET COORDINATES
# not easy to work with longitude and latitude -> UTM
# in this way in order to calculate the distance we can do the euclidean one instead of spherical one
# bubble plot(obj,zcol,...)
# key.space=location of the key
bubble(meuse,'zinc',do.log=TRUE,key.space='bottom')
dev.off()
# river meuse
data(meuse.riv)
meuse.lst <- list(Polygons(list(Polygon(meuse.riv)), "meuse.riv"))
meuse.sr <- SpatialPolygons(meuse.lst)
# grid for prediction
data(meuse.grid)
is(meuse.grid)
coordinates(meuse.grid) <- c('x','y')
meuse.grid <- as(meuse.grid, 'SpatialPixelsDataFrame')
# plot all together
image(meuse.grid, col = "lightgrey")
plot(meuse.sr, col = "grey", add = TRUE)
plot(meuse, add = TRUE)
title('meuse river geostatistical data')
dev.off()
## Exploratory Analysis ##
##----------------------##
# histogram of zinc variable
hist(meuse$zinc, breaks=16, col="grey", main='Histogram of Zn', prob = TRUE, xlab = 'Zn') #asymmetric data
# highly skewed, transform to the log
hist(log(meuse$zinc), breaks=16, col="grey", main='Histogram of log(Zn)', prob = TRUE, xlab = 'log(Zn)')
# scatterplot of log(zinc) with respect to distance from the river
xyplot(log(zinc) ~ sqrt(dist), as.data.frame(meuse))
# Negative correlation: lower distance from the river => higher level of zinc
dev.off()
## Estimating Spatial Correlation ##
##     Variogram Analysis         ##
##--------------------------------##
# sample variogram (binned estimator)
svgm <- variogram(log(zinc) ~ 1, meuse) #response variable ~ 1 #stationary dataset
# Zs = ms + delta_s
# sum_l a_l*f_l(s) + delta_s amd with 1 we say "take only f_0(s)"
plot(svgm, main = 'Sample Variogram',pch=19)
dev.off()
# N.B.  the notation "~ 1" stands for a single constant predictor
#       (hp: spatially constant mean)
# default decisions:
# direction dependence, cutoff, lag width
# the following
plot(variogram(log(zinc) ~ 1, meuse),pch=19)
# automatically decides to ignore direction: point pairs are merged on the
# basis of distance to compute the empirical variogram
plot(variogram(log(zinc) ~ 1, meuse, alpha = c(0, 45, 90, 135)),pch=19)
# point pairs whose separation vector has a given direction are used in each
# panel (not too many directions otherwise noise will increase)
# Note: zonal anisotropy
# cutoff distance: maximum distance up to which point pairs are considered
#                  (default = bbox diagonal / 3)
# lag width: width of distance intervals over which point pairs are averaged
#            in bins (default = cutoff distance / 15)
plot(variogram(log(zinc) ~ 1, meuse, cutoff = 1000, width = 1000/15),pch=19)
# intervals can have different widths: to fix varying widths use the argument
# boudaries
plot(variogram(log(zinc) ~ 1, meuse, boundaries = c(0,200,seq(400,1500,100))),pch=19)
# useful for data sets that have much information on short distance variability
plot(variogram(log(zinc) ~ 1, meuse, cutoff = 1000, width = 1000/5),pch=19)
## Variogram modeling
##-------------------
# FIRST APPROACH -> isotropic variogram, discarding anisotropy (not so good)
# list of parametric isotropic variogram models
vgm()
# in gstat, valid variogram models are constructed by using one or
# combination of two or more basic variogram models
# first argument of the function 'vgm' is partial sill,
# then the desired model, then range, and finally nugget:
# vgm(sill, model, range, nugget)
# some examples...
vgm(1, "Sph", 300)
vgm(1, "Sph", 300, 0.5) #(1, spherical model, 300, nuggets)
# one can also add two or more models
v1 <- vgm(1, "Sph", 300, 0.5)
v2 <- vgm(0.8, "Sph", 800, add.to = v1)
v2
# this is only measurement error
vgm(0.5, "Nug", 0)
## weighted least squares fitting a variogram model to the sample variogram
## STEPS:
## 1) choose a suitable model
## 2) choose suitable initial values for partial sill, range & nugget
## 3) fit the model using one of the possible fitting criteria
v <- variogram(log(zinc) ~ 1, meuse)
plot(v,pch=19)
# Linear behavior near the origin, growth not very fast
# Recall: both spherical and exponential model have a linear behavior near the
#         origin but exponential model has a faster growth than the spherical one
# => we fit a spherical model
# try reasonable initial values
fit.variogram(v, vgm(1, "Sph", 800, 1))
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,450)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
# non stationary variogram v
v <- variogram(bc.med_dwell ~ sqrt(dist), data = data_spat)
plot(v)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
# compare the two variograms
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red')
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red', ylim=c(5.5, 7))
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,450)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,100)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
# non stationary variogram v
v <- variogram(bc.med_dwell ~ sqrt(dist), data = data_spat)
plot(v)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
# compare the two variograms
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red', ylim=c(5.5, 7))
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 6000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
v.f.est<-function(x,C0, ...){C0-cov.spatial(x, ...)}
x11()
plot(v$dist,v$gamma,xlab='distance',ylab='semivariance',pch=19,col='red', ylim=c(5.5, 7))
curve(v.f.est(x, C0=v.fit[2,2]+v.fit[1,2], cov.pars=rbind(c(v.fit[2,2], v.fit[2,3]),c(v.fit[1,2], v.fit[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 3000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='red',lwd=2)
points(v.1$dist,v.1$gamma,xlab='distance',ylab='semivariance',pch=19,col='steelblue')
curve(v.f.est(x, C0=fit1[2,2]+fit1[1,2],
cov.pars=rbind(c(fit1[2,2], fit1[2,3]),c(fit1[1,2], fit1[1,3])), cov.model = c("exponential","pure.nugget")), from = 0.0001, to = 3000,
xlab = "distance", ylab = expression(gamma(h)),
main = "Variogram model",add=TRUE,col='steelblue',lwd=2)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
x11()
plot(v.1, fit1, pch = 3)
v <- variogram(log(med_dwell) ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(0.4, "Exp", 3000, 0.2))
x11()
plot(v, v.fit, pch = 3)
v.fit
# stationary variogram v1
v.1 <- variogram(log(med_dwell) ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(0.4, model='Exp', 5000, nugget=0.2))
x11()
plot(v.1, fit1, pch = 3)
# non stationary variogram v
v <- variogram(log(med_dwell) ~ sqrt(dist), data = data_spat)
plot(v)
# non converge, dato che c'? poca variabilit? tra i dati
v <- variogram(log(med_dwell) ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(0.4, "Exp", 3000, 0.2))
x11()
plot(v, v.fit, pch = 3)
v.fit
x11()
plot(v.1, fit1, pch = 3)
x11()
plot(v, v.fit, pch = 3)
v.fit
x11()
plot(v.1, fit1, pch = 3)
x11()
xyplot(log(med_dwell) ~ sqrt(distance), as.data.frame(data_spat))
library(car)
lambda <- powerTransform(med_dwell)
bc.med_dwell <- bcPower(med_dwell, lambda$lambda)
hist(bc.med_dwell, breaks=16, col="grey", main='Histogram of bc dist', prob = TRUE, xlab = 'bc dist from home')
x11()
xyplot(bc.med_dwell ~ sqrt(dist), as.data.frame(data_spat))
v.1 <- variogram(log(med_dwell) ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(0.4, model='Exp', 5000, nugget=0.2))
fit1
x11()
plot(v.1, fit1, pch = 3)
x11()
plot(v.1, fit1, pch = 3)
v <- variogram(log(med_dwell) ~ sqrt(dist), data = data_spat)
plot(v)
v <- variogram(log(med_dwell) ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(0.4, "Exp", 3000, 0.2))
x11()
plot(v, v.fit, pch = 3)
v.fit
v.1 <- variogram(bc.med_dwell ~ 1, data = data_spat,boundaries = c(0,seq(10,3000,300)))
fit1=fit.variogram(v.1, vgm(6, model='Exp', 5000, nugget=2))
fit1
x11()
plot(v.1, fit1, pch = 3)
v <- variogram(bc.med_dwell ~ sqrt(dist) , data = data_spat,boundaries = c(0,seq(10,3000,300)))
plot(v)
v.fit <- fit.variogram(v, vgm(6, "Exp", 3000, 2))
x11()
plot(v, v.fit, pch = 3)
v.fit
New_York_County=New_York_County[order(New_York_County$area),]
CBG_ny_index = which(census_blocks_ny$County=="New York County")
CBG_ny = census_blocks_ny[CBG_ny_index,]
# make the two datasets equal
remove=c()
k=1
for (i in 1:1170) {
index=which(New_York_County$area==CBG_ny$CensusBlockGroup[i])
if (length(index)==0) {
remove[k]=i
k=k+1
}
}
CBG_ny=CBG_ny[-remove,]
CBG_ny=CBG_ny[order(CBG_ny$CensusBlockGroup),]
CBG_ny_index=CBG_ny_index[-remove]
rm (patterns_ny)
rm (census_blocks_ny)
rm(census_metadata)
#------------------------------------------------------------
# TROVIAMO I CBG DEI FIUMI
track_code_river <- c("027500", "025500", "024700", "024100", "023700", "023300", "022900", "022500", "022301", "021900","021100","020500", "019900", "019500",
"019100", "018700", "018300", "017900", "017500", "017100","016700", "016300", "015900", "015500", "015100", "013500", "012900", "011700", "009900", "007900", "007500", "006900", "003700",
"003900", "031703", "031704","031900", "000500", "000900","000700", "001502", "001501", "002500", "000800","000600","000201", "000202", "001001", "001002", "002000", "002400", "004400",
"006000", "006200", "008601", "008602", "023801", "010601","010602","011600", "012400", "013200", "013600", "023802", "015200","017800", "019200", "024200", "021000", "023600", "024302", "031100",
"029900", "029700", "028700", "022302", "016200", "024000")
index_river=c()
k=1
for (i in 1:dim(CBG_ny)[1]) {
if (CBG_ny$TractCode[i] %in% track_code_river ) {
if (CBG_ny$BlockGroup[i] == "0") {
index_river[k] = i
k=k+1
}
}
}
CBG_ny_no_river<-CBG_ny[-index_river,]
#save (CBG_ny_no_river, file="CBG_NY_no_river.RData")
#-----------------------------------------------------------
# coordinate in utm
# x11()
# plot(st_geometry(CBG_ny_no_river$geometry), xlim = c(-74.1,-73.8), ylim = c(40.68,40.88), xlab = " ", ylab = " ")
# par(new=T)
# plot(st_geometry(CBG_RIVER$geometry), xlim = c(-74.1,-73.8), ylim = c(40.68,40.88), xlab = " ", ylab = " ",col = "lightblue")
# par(new=T)
# plot(centroids, xlim = c(-74.1,-73.8), ylim = c(40.68,40.88), xlab = " ", ylab = " ", pch='.')
#
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
# x11()
# plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
# text(coord.x_long,coord.y_lat, labels=CBG_ny_no_river$CensusBlockGroup, cex=1)
coord<-SpatialPoints(cbind(coord.x_long,coord.y_lat),proj4string=CRS("+proj=longlat"))
coord.UTM.NY <- spTransform(coord, CRS("+proj=utm +zone=18 +datum=WGS84"))
coord.x <- coord.UTM.NY@coords[,1]
coord.y <- coord.UTM.NY@coords[,2]
centroids_river <- st_centroid(CBG_RIVER$geometry, of_largest_polygon = FALSE)
coord_river <- as.numeric(unlist(centroids_river))
coord_riv.x_long <- coord_river[seq(1,length(coord_river),by=2)]
coord_riv.y_lat <- coord_river[seq(2,length(coord_river),by=2)]
coord<-SpatialPoints(cbind(coord_riv.x_long,coord_riv.y_lat),proj4string=CRS("+proj=longlat"))
coord.UTM.riv <- spTransform(coord, CRS("+proj=utm +zone=18 +datum=WGS84"))
coord_riv.x <- coord.UTM.riv@coords[,1]
coord_riv.y <- coord.UTM.riv@coords[,2]
k <- which(CBG_ny_no_river$TractCode == '011300')
centroid_TimesSquare <- st_centroid(CBG_ny_no_river$geometry[k,], of_largest_polygon = FALSE)
coord_cTS <- as.numeric(unlist(centroid_TimesSquare))
coord_cTS.x_long <- coord_cTS[1]
coord_cTS.y_lat <- coord_cTS[2]
dist=distm(cbind(coord.x_long, coord.y_lat), cbind(coord_riv.x_long, coord_riv.y_lat), fun = distGeo)
#SCELTA REGRESSORE:f(s_i)
#f(s_i) = distanza dal fiume
distance<-c()
for (i in 1:1092)
distance[i]<-dist[i,which.min(dist[i,])]
#f(s_i) = distanza da ipotetico centro di times square
distance<-distm(cbind(coord.x_long, coord.y_lat), cbind(coord_cTS.x_long, coord_cTS.y_lat), fun = distGeo)
New_York_County<-New_York_County[-index_river,]
attach(New_York_County)
#f(s_i) = distance from home
distance <- distance_from_home
#f(s_i) = distance from primary location
distance <- distance_from_primary_daytime_location
data_spatial <-data.frame(coord.x,coord.y, median_dwell, distance)
coordinates(data_spatial)<-c('coord.x', 'coord.y')
#box cox transformation --------------------------------------------------------
library(car)
lambda <- powerTransform(median_dwell)
bc.median_dwell <- bcPower(median_dwell, lambda$lambda)
# histogram of median_dwell variable
hist(median_dwell, breaks=16, col="grey", main='Histogram of median dwell', prob = TRUE, xlab = 'median dwell') #asymmetric data
# highly skewed, transform to the log
hist(log(median_dwell), breaks=16, col="grey", main='Histogram of log(median_dwell)', prob = TRUE, xlab = 'log(median_dwell)')
hist(bc.median_dwell, breaks=16, col="grey", main='Histogram of log(median_dwell)', prob = TRUE, xlab = 'log(median_dwell)')
x11()
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry, aes(fill=median_dwell))+scale_fill_gradient(low="lightyellow", high="black") +
geom_sf(data = CBG_RIVER$geometry, fill = "lightblue")
New_York_County_no_river=New_York_County_no_river[order(New_York_County_no_river$area),]
CBG_ny_no_river=CBG_ny_no_river[order(CBG_ny_no_river$CensusBlockGroup),]
attach(New_York_County_no_river)
#coordinate in utm
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
coord<-SpatialPoints(cbind(coord.x_long,coord.y_lat),proj4string=CRS("+proj=longlat"))
coord.UTM.NY <- spTransform(coord, CRS("+proj=utm +zone=18 +datum=WGS84"))
coord.x <- coord.UTM.NY@coords[,1]
coord.y <- coord.UTM.NY@coords[,2]
#diversi z da vedere
#z<- ....
##focus su DISTANCE_FROM_HOME
rem <- which(distance_from_home > 20000) #[36] > 125000, [175]  > 50000, [1,9] >30000 , [92] >20000
CBG_ny_no_river$CensusBlockGroup[rem]
#dati molto alti che non fanno vedere pattern nel grafico -> da capire se togliere o no
min(distance_from_home)
max(distance_from_home)
# data_spatial <-data.frame(coord.x,coord.y, z)
# coordinates(data_spatial)<-c('coord.x', 'coord.y')
x11()
png(file = "glop distance from home")
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry[-rem], aes(fill=distance_from_home[-rem]))+scale_fill_gradient(low="lightyellow", high="red") +
geom_sf(data = CBG_ny_no_river$geometry[rem,], fill="black")+
geom_sf(data = CBG_ny_no_river$geometry[which(CBG_ny_no_river$TractCode=="011300"),], fill="yellow") +
geom_sf(data = CBG_RIVER$geometry, fill="lightblue")
x11()
#png(file = "glop distance from home")
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry[-rem], aes(fill=distance_from_home[-rem]))+scale_fill_gradient(low="lightyellow", high="red") +
geom_sf(data = CBG_ny_no_river$geometry[rem,], fill="black")+
geom_sf(data = CBG_ny_no_river$geometry[which(CBG_ny_no_river$TractCode=="011300"),], fill="yellow") +
geom_sf(data = CBG_RIVER$geometry, fill="lightblue")
distance__from_home <-distance_from_home[-rem]
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry[-rem], aes(fill=distance__from_home))+scale_fill_gradient(low="lightyellow", high="red") +
geom_sf(data = CBG_ny_no_river$geometry[rem,], fill="black")+
geom_sf(data = CBG_ny_no_river$geometry[which(CBG_ny_no_river$TractCode=="011300"),], fill="yellow") +
geom_sf(data = CBG_RIVER$geometry, fill="lightblue")
