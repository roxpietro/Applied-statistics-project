# Loading libraries
library(car)
# terri
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Data frame county/New York County.RData") #TERRI
New_York_County<-New_York_County[-92,]
attach(New_York_County)
LM_1=data.frame(median_dwell,raw_stop_counts,raw_device_counts,distance_from_home,distance_from_primary_daytime_location)
detach(New_York_County)
attach(LM_1)
## vediamo come sono distribuiti i dati
pairs(LM_1) #(male)
# # facciamo un linear model solo con le prime due variabili (risultati molto bassi)
# mod=lm(formula = median_dwell ~ raw_stop_counts + raw_device_counts)
# summary(mod)
#
# # Dobbiamo trovare una trasformazione che renda il modello pi? lineare
#
# #-------------------------------------------------------------------------------
# #1. decidiamo di fare il boxcox del modello (univariate)
# #-------------------------------------------------------------------------------
#
b=boxCox(mod)
# # facciamo un linear model solo con le prime due variabili (risultati molto bassi)
mod=lm(formula = median_dwell ~ raw_stop_counts + raw_device_counts)
summary(mod)
#
# # Dobbiamo trovare una trasformazione che renda il modello pi? lineare
#
# #-------------------------------------------------------------------------------
# #1. decidiamo di fare il boxcox del modello (univariate)
# #-------------------------------------------------------------------------------
#
b=boxCox(mod)
best_lambda_ind=which.max(b$y)
lambda=b$x[best_lambda_ind]
box_cox <- function(x,lambda)
{
if(lambda!=0)
return((x^lambda-1)/lambda)
return(log(x))
}
new_raw_stop_counts = box_cox(raw_stop_counts,lambda)
new_raw_device_counts = box_cox(raw_device_counts,lambda)
new_median_dwell = box_cox(median_dwell,lambda)
mod_boxcox=lm(formula = new_median_dwell ~ new_raw_stop_counts + new_raw_device_counts)
summary(mod_boxcox) #0.38
# #-------------------------------------------------------------------------------
# #2. Proviamo a vedere se cambia qualcosa con il Powertransformation di ogni variabile (univariate)
# #--------------------------------------------------------------------------------
lambda.raw_stop <- powerTransform(raw_stop_counts)
lambda.raw_device <- powerTransform(raw_device_counts)
lambda.median <- powerTransform(median_dwell)
bc.raw_stop <- bcPower(raw_stop_counts, lambda.raw_stop$lambda)
bc.raw_device <- bcPower(raw_device_counts, lambda.raw_device$lambda)
bc.median <- bcPower(median_dwell, lambda.median$lambda)
mod_power=lm(formula = bc.median ~ bc.raw_stop + bc.raw_device)
summary(mod_power) #0.475
mod_power=lm(formula = median_dwell ~ bc.raw_stop + bc.raw_device)
summary(mod_power) #0.496
mod_power=lm(formula = bc.median ~ raw_stop_counts + raw_device_counts)
summary(mod_power) #0.03
mod_power=lm(formula = bc.median ~ bc.raw_stop + bc.raw_device)
summary(mod_power) #0.478
# #----------------------------------------------------------------------------
# #3. Multivariate case
# #----------------------------------------------------------------------------
lambda_multivariate <- powerTransform(cbind(raw_stop_counts, raw_device_counts,median_dwell))
lambda_multivariate
BC.stop <- bcPower(raw_stop_counts, 0)
BC.device <- bcPower(raw_device_counts, 0)
BC.median <- bcPower(median_dwell, lambda_multivariate$lambda[3])
mod_multivariate=lm(formula = BC.median ~ BC.stop + BC.device)
summary(mod_multivariate) #0.692
# ######################################### SECONDO MODELLO: AGGIUNGO FEATURES ##########################################
#
# #4. Provo con questo metodo ad aggiungere features
#
lambda_multivariate <- powerTransform(cbind(raw_stop_counts, raw_device_counts,distance_from_home,distance_from_primary_daytime_location,median_dwell))
lambda_multivariate
BC.stop <- bcPower(raw_stop_counts, 0)
BC.device <- bcPower(raw_device_counts, 0)
BC.home <- bcPower(distance_from_home, lambda_multivariate$lambda[3])
BC.primary <- bcPower(distance_from_primary_daytime_location, lambda_multivariate$lambda[4])
BC.median <- bcPower(median_dwell, lambda_multivariate$lambda[5])
mod_multivariate_complete=lm(formula = BC.median ~ BC.stop + BC.device + BC.primary + BC.home)
summary(mod_multivariate_complete) #0.6932
vif(mod_multivariate_complete) # c'? collinearit?
LM_2 <- data.frame(BC.stop,BC.device ,BC.home,BC.primary,median_dwell )
pairs(LM_2)
par(mfrow=c(2,2))
plot(mod_multivariate_complete)
shapiro.test(residuals(mod_multivariate_complete))
x11()
pairs(LM_2)
x11()
plot(raw_stop_counts, median_dwell, xlim = c(0,20000))
plot(raw_device_counts, median_dwell, xlim = c(0,10000))
plot(distance_from_home, median_dwell, xlim = c(0,20000))
plot(distance_from_primary_daytime_location, median_dwell, xlim = c(0,20000))
x11()
plot(raw_stop_counts, median_dwell, xlim = c(0,20000))
plot(raw_device_counts, median_dwell, xlim = c(0,10000))
plot(distance_from_home, median_dwell, xlim = c(0,20000))
plot(distance_from_primary_daytime_location, median_dwell, xlim = c(0,20000))
pairs(LM_2)
par(mfrow=c(2,2))
plot(mod_multivariate_complete)
LM_2 <- data.frame(BC.stop,BC.device ,BC.home,BC.primary,median_dwell )
pairs(LM_2)
LM_2 <- data.frame(BC.stop,BC.device ,BC.home,BC.primary,median_dwell )
x11()
pairs(LM_2)
plot(Bc.stop, median_dwell)
plot(BC.stop, median_dwell)
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/River_Dataset.RData")
New_York_County_no_river=New_York_County_no_river[order(New_York_County_no_river$area),]
CBG_ny_no_river=CBG_ny_no_river[order(CBG_ny_no_river$CensusBlockGroup),]
attach(New_York_County_no_river)
### guardiamo da dove arriva la gente che va lì: HOME
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Conversione dal dataset originale ad adesso/Cyber_Capital.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Complete_dataset.RData")
rm(patterns_ny)
rm(census_metadata)
# order patterns_ny and census_block_ny by CBG of New York County
complete_dataset = complete_dataset[order(complete_dataset$area),]
census_blocks_ny = census_blocks_ny[order(census_blocks_ny$CensusBlockGroup),]
#remove not common cbg
remove <- which(census_blocks_ny$CensusBlockGroup %in% complete_dataset$area == FALSE)
census_blocks_ny <- census_blocks_ny[-remove,]
dim(census_blocks_ny)
inside <- c()
tot_home <- c()
home <- c()
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k <- which(census_blocks_ny$CensusBlockGroup == home[i])
if (length(k) != 0){
tot <- tot+1
index_home[tot] <-k
}
}
inside[j] <- tot
}
outside <- tot_home-inside
remove <- which(inside>=1100 | outside>=300)
remove
inside[remove]
outside[remove]
col = rep('black',1092)
col[remove] = 'red'
x11()
plot(outside, inside, main='Scatterplot outside vs inside NY state', lwd=2,
xlab='outside', ylab='inside', col = col)
text(outside, inside, dimnames(inout)[[1]],cex=1)
new_inside <- inside[-remove]
new_outside <- outside[-remove]
new_mod <- lm(new_inside ~ new_outside)
summary(new_mod) #Adjusted R-squared: 0.7185,  pvalue bassisimi
shapiro.test(new_mod$residuals) #< 2.2e-16
x11()
par(mfrow = c(2,2))
plot(new_mod)
library(geosphere)
library(sf)
library(sp)           ## Data management
library(lattice)      ## Data management
library(geoR)         ## Geostatistics
library(gstat)        ## Geostatistics
library(ggplot2)
library(raster)
library(rgdal)
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/River_Dataset.RData")
#coordinate in utm
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
coord<-SpatialPoints(cbind(coord.x_long,coord.y_lat),proj4string=CRS("+proj=longlat"))
coord.UTM.NY <- spTransform(coord, CRS("+proj=utm +zone=18 +datum=WGS84"))
coord.x <- coord.UTM.NY@coords[,1]
coord.y <- coord.UTM.NY@coords[,2]
rem_out <- which(outside>=300)
rem_in <- which(inside>=1100)
obj <-outside[-remove]
x11()
#png(file = "glop distance from home.png")
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry[-remove], aes(fill=obj))+scale_fill_gradient(low="yellow", high="red") +
geom_sf(data = CBG_ny_no_river$geometry[-remove]) +
geom_sf(data = CBG_ny_no_river$geometry[remove,], fill="violet")+
geom_sf(data = CBG_RIVER$geometry, fill="lightblue")
####### guardiamo la percentuale di gente per igni cbg che viene da fuori ######
out_NY_city <- c()
out_NY_state <-c()
inside <- c()
tot_home <- c()
home <- c()
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k_state <- which(census_blocks_ny$CensusBlockGroup == home[i])
k_city <- which(CBG_ny_no_river$CensusBlockGroup == home[i])
if (length(k_state) != 0){
tot <- tot+1
index_home[tot] <-k_state
}
else{
out_NY_state[j] <- sum(out_NY_state[j],home[i])
}
if (length(k_city) != 0){
tot <- tot+1
index_home[tot] <-k_city
}
else{
out_NY_city[j] <- sum(out_NY_city[j],home[i])
}
}
inside[j] <- tot
}
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k_state <- which(census_blocks_ny$CensusBlockGroup == home[i])
k_city <- which(CBG_ny_no_river$CensusBlockGroup == home[i])
if (length(k_state) != 0){
tot <- tot+1
index_home[tot] <-k_state
}
else{
out_NY_state[j] <- sum(out_NY_state[j],device_home_areas[[j]][i])
}
if (length(k_city) != 0){
tot <- tot+1
index_home[tot] <-k_city
}
else{
out_NY_city[j] <- sum(out_NY_city[j],device_home_areas[[j]][i])
}
}
inside[j] <- tot
}
####### guardiamo la percentuale di gente per igni cbg che viene da fuori ######
out_NY_city <- c()
out_NY_state <-c()
inside <- c()
tot_home <- c()
home <- c()
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k_state <- which(census_blocks_ny$CensusBlockGroup == home[i])
k_city <- which(CBG_ny_no_river$CensusBlockGroup == home[i])
if (length(k_state) != 0){
tot <- tot+1
index_home[tot] <-k_state
}
else{
out_NY_state[j] <- sum(out_NY_state[j],device_home_areas[[j]][i])
}
if (length(k_city) != 0){
tot <- tot+1
index_home[tot] <-k_city
}
else{
out_NY_city[j] <- sum(out_NY_city[j],device_home_areas[[j]][i])
}
}
inside[j] <- tot
}
####### guardiamo la percentuale di gente per igni cbg che viene da fuori ######
out_NY_city <- rep(0, dim(New_York_County_no_river)[1])
out_NY_state <-rep(0, dim(New_York_County_no_river)[1])
inside <- c()
tot_home <- c()
home <- c()
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k_state <- which(census_blocks_ny$CensusBlockGroup == home[i])
k_city <- which(CBG_ny_no_river$CensusBlockGroup == home[i])
if (length(k_state) == 0){
out_NY_state[j] <- sum(out_NY_state[j],device_home_areas[[j]][i])
}
if (length(k_city) == 0){
out_NY_city[j] <- sum(out_NY_city[j],device_home_areas[[j]][i])
}
}
inside[j] <- tot
}
which(out_NY_city ==0 &out_NY_state!=0)
outside <- tot_home-inside
View(New_York_County_no_river)
View(New_York_County_no_river)
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/River_Dataset.RData")
New_York_County_no_river = New_York_County_no_river[order(New_York_County_no_river$area),]
CBG_ny_no_river = CBG_ny_no_river[order(CBG_ny_no_river$CensusBlockGroup),]
attach(New_York_County_no_river)
### guardiamo da dove arriva la gente che va lì: HOME
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Conversione dal dataset originale ad adesso/Cyber_Capital.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Complete_dataset.RData")
rm(patterns_ny)
rm(census_metadata)
# order patterns_ny and census_block_ny by CBG of New York County
complete_dataset = complete_dataset[order(complete_dataset$area),]
census_blocks_ny = census_blocks_ny[order(census_blocks_ny$CensusBlockGroup),]
#remove not common cbg
remove <- which(census_blocks_ny$CensusBlockGroup %in% complete_dataset$area == FALSE)
census_blocks_ny <- census_blocks_ny[-remove,]
dim(census_blocks_ny)
#misurare quante home di device home from areas vengono da fuori NY state
inside <- c()
tot_home <- c()
home <- c()
library(geosphere)
library(sf)
library(sp)           ## Data management
library(lattice)      ## Data management
library(geoR)         ## Geostatistics
library(gstat)        ## Geostatistics
library(ggplot2)
library(raster)
library(rgdal)
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/River_Dataset.RData")
#coordinate in utm
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
coord<-SpatialPoints(cbind(coord.x_long,coord.y_lat),proj4string=CRS("+proj=longlat"))
coord.UTM.NY <- spTransform(coord, CRS("+proj=utm +zone=18 +datum=WGS84"))
coord.x <- coord.UTM.NY@coords[,1]
coord.y <- coord.UTM.NY@coords[,2]
#remove <- which(inside>=1100 | outside>=300)
rem_out <- which(outside>=300)
rem_in <- which(inside>=1100)
home_out_NYstate <-outside[-remove]
x11()
####### guardiamo la percentuale di gente per igni cbg che viene da fuori ######
out_NY_city <- rep(0, dim(New_York_County_no_river)[1]) #conterà quanti hanno casa fuori da manhattan
out_NY_state <-rep(0, dim(New_York_County_no_river)[1]) #conterà quanti hanno casa fuori da ny state
in_NY_state <- rep(0, dim(New_York_County_no_river)[1])
in_NY_city<- rep(0, dim(New_York_County_no_river)[1])
tot_home <- c()
home <- c()
for (j in 1:dim(New_York_County_no_river)[1]){
home <- names(device_home_areas[[j]])
tot_home[j] <- length(home)
index_home <- c()
tot <- 0
for (i in 1: length(home)){
k_state <- which(census_blocks_ny$CensusBlockGroup == home[i])
k_city <- which(CBG_ny_no_river$CensusBlockGroup == home[i])
if (length(k_state) == 0){
out_NY_state[j] <- sum(out_NY_state[j],device_home_areas[[j]][i])
}
else{
in_NY_state[j] <- sum(in_NY_state[j], device_home_areas[[j]][i])
}
if (length(k_city) == 0){
out_NY_city[j] <- sum(out_NY_city[j],device_home_areas[[j]][i])
}
else{
in_NY_city[j] <- sum(in_NY_city[j], device_home_areas[[j]][i])
}
}
inside[j] <- tot
}
#check mongolo
which(out_NY_city ==0 & out_NY_state !=0)
which(in_NY_city !=0 & in_NY_state ==0)
outside <- tot_home-inside
data <- data.frame(city = out_NY_city, state = out_NY_state)
pairs(data)
#facciamo percentuale
perc.out_NY_city <- out_NY_city / sum_device_home_areas
perc.out_NY_state <- out_NY_state / sum_device_home_areas
perc.in_NY_city <- in_NY_city / sum_device_home_areas
perc.in_NY_state <- in_NY_state / sum_device_home_areas
percentage_out_Manhattan <- perc.out_NY_city
library(mvtnorm)
library(rgl)
library(car)
data <- cbind(perc.out_NY_city, perc.out_NY_state)
iris.e <- dist(data, method='euclidean')
iris.ea <- hclust(iris.e, method='average') #average linkage
iris.ec <- hclust(iris.e, method='complete')
iris.ew <- hclust(iris.e, method='ward.D2')
cluster.ea2 <- cutree(iris.ea, k=2)
cluster.ea3 <- cutree(iris.ea, k=3)
coph.ea <- cophenetic(iris.ea)
# compute cophenetic coefficients CPCC
ea <- cor(iris.e, coph.ea)
cluster.ec2 <- cutree(iris.ec, k=2)
cluster.ec3 <- cutree(iris.ec, k=3)
coph.ec <- cophenetic(iris.ec)
# compute cophenetic coefficients CPCC
ec <- cor(iris.e, coph.ec)
cluster.ew2 <- cutree(iris.ew, k=2)
cluster.ew3 <- cutree(iris.ew, k=3)
coph.ew <- cophenetic(iris.ew)
# compute cophenetic coefficients CPCC
ew <- cor(iris.e, coph.ew)
cophenetic_coefficient <- data.frame(Eucl_Compl = ec, Eucl_Av = ea, Eucl_Ward = ew)
setwd("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/ANALISI SPAZIALE CON FIUME/analysis home")
png(file = "dati EA k2.png")
plot(perc.out_NY_city, perc.out_NY_state, col =my_col, xab="percentage of home outside Manhattan",
ylab="percentage of home outside New Yorl State", main="Eucledian-Average with k=2")
dev.off()
png(file = "dati EA k2.png")
plot(perc.out_NY_city, perc.out_NY_state, col =my_col, xlab="percentage of home outside Manhattan",
ylab="percentage of home outside New Yorl State", main="Eucledian-Average with k=2")
#EUCLEDIAN-AVERAGE
#k=2
cluster.ec3
my_col = rep('red', 1092)
my_col[which(cluster.ec2 == 2)] = 'blue'
png(file = "EA k2.png")
ggplot() +
geom_sf(data = CBG_ny_no_river$geometry, fill = my_col) +
geom_sf(data = CBG_RIVER$geometry, fill="lightblue")+
labs(title='Map of the Clustering')
dev.off()
png(file = "dati EA k2.png")
plot(perc.out_NY_city, perc.out_NY_state, col =my_col, xlab="percentage of home outside Manhattan",
ylab="percentage of home outside New Yorl State", main="Eucledian-Average with k=2")
dev.off()
