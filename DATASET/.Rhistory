ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
# outliers
out=c(566,106,1157)
cbg_out=New_York_County[out,1]
cbg_out
matplot(stops,type='l')
lines(stops[,228],lwd=4, col=2)
lines(stops[,871],lwd=4, col=1)
lines(stops[,267],lwd=4, col=3)
matplot(stops,type='l')
lines(stops[,566],lwd=4, col=2)
lines(stops[,106],lwd=4, col=1)
lines(stops[,1157],lwd=4, col=3)
# togliamo questi outliers
stops<-stops[,-out]
matplot(stops,type='l')
New_York_County_no_river<-New_York_County_no_river[-which(New_York_County_no_river$area %in% cbg_out),]
View(New_York_County_no_river)
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/NYC_no_river.RData")
New_York_County_no_river<-New_York_County_no_river[-which(New_York_County_no_river$area %in% cbg_out),]
New_York_County_no_river=New_York_County_no_river[order(New_York_County_no_river$area),]
attach(New_York_County_no_river)
stops<-matrix(nrow = 1090, ncol=30)
for (i in 1:1090) {
stops[i,]<-stops_by_day[[i]]
}
detach(New_York_County_no_river)
stops<-t(stops)
matplot(stops,type='l')
nbasis <- 29
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
arm=5 #numero armoniche
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
New_York_County_no_river[360,1]
x<-t(matrix((time)))
Xsp <- smooth.basis(argvals=time, y=stops, fdParobj=basis) # easier because it includes also penalization (see later)
Xsp0 <- eval.fd(time, Xsp$fd) #  the curve smoothing the data
fdakma_example <- kma(
x=x,
y0=t(Xsp0),
# y1=t(Xsp1),
n.clust = 3,
warping.method = 'affine', # trasformation of an axis in order to do align
similarity.method = 'd0.pearson',  # similarity computed as the cosine
# between the first derivatives
# (correlation)
center.method = 'k-means'
#seeds = c(1,21) # you can give a little help to the algorithm...
)
library(fdakma)
fdakma_example <- kma(
x=x,
y0=t(Xsp0),
# y1=t(Xsp1),
n.clust = 3,
warping.method = 'affine', # trasformation of an axis in order to do align
similarity.method = 'd0.pearson',  # similarity computed as the cosine
# between the first derivatives
# (correlation)
center.method = 'k-means'
#seeds = c(1,21) # you can give a little help to the algorithm...
)
Xsp1 <- eval.fd(time, Xsp$fd, Lfd=1) # first derivative
kma.compare_example2 <- kma.compare (
x=x, y0=y0, y1=y1, n.clust = 1:3,
warping.method = c('affine', 'dilatation','shift'),
similarity.method = 'd1.pearson',
center.method = 'k-means',
seeds = c(1,21,30),
plot.graph=1)
kma.compare_example2 <- kma.compare (
x=x, y0=t(Xsp0), y1=t(Xsp1), n.clust = 1:3,
warping.method = c('affine', 'dilatation','shift'),
similarity.method = 'd1.pearson',
center.method = 'k-means',
seeds = c(1,21,30),
plot.graph=1)
warnings()
nbasis <- 20
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
nbasis <- 20
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 21
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 19
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
nbasis <- 18
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
nbasis <- 18
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 17
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 16
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 21
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 15
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 17
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
nbasis <- 20
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 22
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
nbasis <- 19
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
matplot(stops,type='l')
nbasis <- 22
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
arm=5 #numero armoniche
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
x11()
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
setwd("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET")
library(geosphere)
library(sf)
library(sp)           ## Data management
library(lattice)      ## Data management
library(geoR)         ## Geostatistics
library(gstat)        ## Geostatistics
library(ggplot2)
library(raster)
# fra
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/Data frame county/New York County.RData") # FRA
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/Conversione dal dataset originale ad adesso/Cyber_Capital.RData")
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/River_Dataset.RData")
# terri
#load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Data frame county/New York County.RData") #TERRI
#load("/home/terri/Documenti/UNIVERSITA/STAT APP/progetto/gitcode/Applied-statistics-project/DATASET/Conversione dal dataset originale ad adesso/Cyber_Capital.RData")
# order patterns_ny and census_block_ny by CBG of New York County
New_York_County=New_York_County[order(New_York_County$area),]
CBG_ny_index = which(census_blocks_ny$County=="New York County")
CBG_ny = census_blocks_ny[CBG_ny_index,]
# make the two datasets equal
remove=c()
k=1
for (i in 1:1170) {
index=which(New_York_County$area==CBG_ny$CensusBlockGroup[i])
if (length(index)==0) {
remove[k]=i
k=k+1
}
}
CBG_ny=CBG_ny[-remove,]
CBG_ny=CBG_ny[order(CBG_ny$CensusBlockGroup),]
CBG_ny_index=CBG_ny_index[-remove]
rm (patterns_ny)
rm (census_blocks_ny)
rm(census_metadata)
#------------------------------------------------------------
# TROVIAMO I CBG DEI FIUMI
track_code_river <- c("027500", "025500", "024700", "024100", "023700", "023300", "022900", "022500", "022301", "021900","021100","020500", "019900", "019500",
"019100", "018700", "018300", "017900", "017500", "017100","016700", "016300", "015900", "015500", "015100", "013500", "012900", "011700", "009900", "007900", "007500", "006900", "003700",
"003900", "031703", "031704","031900", "000500", "000900","000700", "001502", "001501", "002500", "000800","000600","000201", "000202", "001001", "001002", "002000", "002400", "004400",
"006000", "006200", "008601", "008602", "023801", "010601","010602","011600", "012400", "013200", "013600", "023802", "015200","017800", "019200", "024200", "021000", "023600", "024302", "031100",
"029900", "029700", "028700", "022302", "016200", "024000")
index_river=c()
k=1
for (i in 1:dim(CBG_ny)[1]) {
if (CBG_ny$TractCode[i] %in% track_code_river ) {
if (CBG_ny$BlockGroup[i] == "0") {
index_river[k] = i
k=k+1
}
}
}
CBG_ny_no_river<-CBG_ny[-index_river,]
save (CBG_ny_no_river, file="CBG_NY_no_river.RData")
# fra
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/Data frame county/New York County.RData") # FRA
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
New_York_County=New_York_County[order(New_York_County$area),]
attach(New_York_County)
stops<-matrix(nrow = 1168, ncol=30)
for (i in 1:dim(New_York_County)[1]) {
stops[i,]<-stops_by_day[[i]]
}
detach(New_York_County)
stops<-t(stops)
colnames(stops)<-New_York_County$area
matplot(stops,type='l')
#B-SPLINES
# Set parameters
nbasis <- 13
m <- 3+1        # spline order
# spline degree  #DEGREE = ORDER - 1
basis <- create.bspline.basis(rangeval=c(1,30), nbasis=nbasis, norder=m)
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1)
arm=5 #numero armoniche
plot.fd(data_W.fd.1)
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
par(mfrow=c(1,2))
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
# outliers
out=c(566,106,1157)
cbg_out=New_York_County[out,1]
layout(1)
matplot(stops,type='l')
lines(stops[,566],lwd=4, col=2)
lines(stops[,106],lwd=4, col=1)
lines(stops[,1157],lwd=4, col=3)
# togliamo questi outliers
stops<-stops[,-out]
matplot(stops,type='l')
New_York_County_no_river<-New_York_County_no_river[-which(New_York_County_no_river$area %in% cbg_out),]
New_York_County_no_river=New_York_County_no_river[order(New_York_County_no_river$area),]
attach(New_York_County_no_river)
stops<-matrix(nrow = 1090, ncol=30)
for (i in 1:1090) {
stops[i,]<-stops_by_day[[i]]
}
detach(New_York_County_no_river)
stops<-t(stops)
matplot(stops,type='l')
nbasis <- 22
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
arm=5 #numero armoniche
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
text(coord.x_long,coord.y_lat, labels=CBG_ny_no_river$CensusBlockGroup, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
CBG_ny_no_river=CBG_ny_no_river[order(CBG_ny_no_river$CensusBlockGroup),]
# fra
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/Data frame county/New York County.RData") # FRA
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/NYC_no_river.RData")
load("C:/Users/franc/Desktop/PoliMI/Anno Accademico 2020-2021/Applied Statistics/Progetto/Applied-statistics-project/DATASET/CBG_NY_no_river.RData")
#--------------------------------------------------------------------
# Build dataset
New_York_County=New_York_County[order(New_York_County$area),]
attach(New_York_County)
stops<-matrix(nrow = 1168, ncol=30)
for (i in 1:dim(New_York_County)[1]) {
stops[i,]<-stops_by_day[[i]]
}
detach(New_York_County)
stops<-t(stops)
colnames(stops)<-New_York_County$area
matplot(stops,type='l')
#B-SPLINES
# Set parameters
nbasis <- 13
m <- 3+1        # spline order
# spline degree  #DEGREE = ORDER - 1
basis <- create.bspline.basis(rangeval=c(1,30), nbasis=nbasis, norder=m)
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1)
# FPCA
arm=5 #numero armoniche
plot.fd(data_W.fd.1)
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
par(mfrow=c(1,2))
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
# togliamo questi outliers
stops<-stops[,-out]
# outliers
out=c(566,106,1157)
cbg_out=New_York_County[out,1]
layout(1)
matplot(stops,type='l')
lines(stops[,566],lwd=4, col=2)
lines(stops[,106],lwd=4, col=1)
lines(stops[,1157],lwd=4, col=3)
# togliamo questi outliers
stops<-stops[,-out]
matplot(stops,type='l')
New_York_County_no_river<-New_York_County_no_river[-which(New_York_County_no_river$area %in% cbg_out),]
CBG_ny_no_river<-CBG_ny_no_river[-which(CBG_ny_no_river$CensusBlockGroup %in% cbg_out),]
New_York_County_no_river=New_York_County_no_river[order(New_York_County_no_river$area),]
CBG_ny_no_river=CBG_ny_no_river[order(CBG_ny_no_river$CensusBlockGroup),]
attach(New_York_County_no_river)
stops<-matrix(nrow = 1090, ncol=30)
for (i in 1:1090) {
stops[i,]<-stops_by_day[[i]]
}
detach(New_York_County_no_river)
stops<-t(stops)
matplot(stops,type='l')
nbasis <- 22
basis <- create.fourier.basis(rangeval=c(1,30),nbasis=nbasis) # creates a fourier basis
time=1:30
data_W.fd.1 <- Data2fd(y = stops,argvals = time,basisobj = basis) #SMOOTHING
plot.fd(data_W.fd.1, ylim = c(0,2000))
arm=5 #numero armoniche
pca_W.1 <- pca.fd(data_W.fd.1,nharm=arm,centerfns=TRUE) #build a functional object before run it -> smoothing preprocessing
# scree plot
# pca.fd computes all the 365 eigenvalues, but only the first are non null
plot(pca_W.1$values[1:5],xlab='j',ylab='Eigenvalues')
plot(cumsum(pca_W.1$values)[1:5]/sum(pca_W.1$values),xlab='j',ylab='CPV',ylim=c(0.8,1))
layout(cbind(1,2,3))
plot(pca_W.1$harmonics[1,],col=1,ylab='FPC1')
abline(h=0,lty=2)
plot(pca_W.1$harmonics[2,],col=2,ylab='FPC2')
plot(pca_W.1$harmonics[3,],col=2,ylab='FPC3')
par(mfrow=c(1,3))
plot.pca.fd(pca_W.1, nx=100, pointplot=TRUE, harm=c(1,2,3), expand=0, cycle=FALSE)
# scatter plot of the scores
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],xlab="Scores FPC1",ylab="Scores FPC2",lwd=2)
text(pca_W.1$scores[,1],pca_W.1$scores[,2], labels=New_York_County$area, cex=1)
x11()
plot(pca_W.1$scores[,1],pca_W.1$scores[,2],type="n",xlab="Scores FPC1",
ylab="Scores FPC2")
text(pca_W.1$scores[,1],pca_W.1$scores[,2], cex=1)
centroids_NY <- st_centroid(CBG_ny_no_river$geometry, of_largest_polygon = FALSE)
coord_NY <- as.numeric(unlist(centroids_NY))
coord.x_long <- coord_NY[seq(1,length(coord_NY),by=2)]
coord.y_lat <- coord_NY[seq(2,length(coord_NY),by=2)]
help("text")
text(coord.x_long[346],coord.y_lat[346], labels=CBG_ny_no_river$CensusBlockGroup[346], cex=1, col='red')
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
text(coord.x_long,coord.y_lat, labels=CBG_ny_no_river$CensusBlockGroup, cex=1)
outliers<-c(346,358)
text(coord.x_long[346],coord.y_lat[346], labels=CBG_ny_no_river$CensusBlockGroup[346], cex=1, col='red')
text(coord.x_long[358],coord.y_lat[358], labels=CBG_ny_no_river$CensusBlockGroup[358], cex=1, col='red')
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
text(coord.x_long,coord.y_lat, labels=CBG_ny_no_river$CensusBlockGroup, cex=1)
outliers<-c(346,358)
points(coord.x_long[346],coord.y_lat[346], labels=CBG_ny_no_river$CensusBlockGroup[346], cex=1, col='red')
points(coord.x_long[358],coord.y_lat[358], labels=CBG_ny_no_river$CensusBlockGroup[358], cex=1, col='red')
#---------------------
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
outliers<-c(346,358)
points(coord.x_long[346],coord.y_lat[346], labels=CBG_ny_no_river$CensusBlockGroup[346], cex=1, col='red')
points(coord.x_long[358],coord.y_lat[358], labels=CBG_ny_no_river$CensusBlockGroup[358], cex=1, col='red')
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
outliers<-c(346,358)
points(coord.x_long[346],coord.y_lat[346], cex=2, col='red')
points(coord.x_long[358],coord.y_lat[358], cex=2, col='red')
x11()
plot(coord.x_long,coord.y_lat,xlab="longitude",ylab="latitude",lwd=2)
outliers<-c(346,358)
points(coord.x_long[outliers],coord.y_lat[outliers], cex=2, col='red')
